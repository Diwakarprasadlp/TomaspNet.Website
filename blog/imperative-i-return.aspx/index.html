<!DOCTYPE html>
<!--[if IE 8]> 				 <html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->

<head>
  <meta charset="utf-8">
  <title>Imperative computation in F# (I.) - Returning results from a function</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Even though F# supports some imperative constructs such as for and while loops, it doesn't support some of the advanced constructs like imperative return and break. In this series, we'll look how we can implement these constructs ourselves using F# computation expressions.">
  <meta name="author" content="Tomas Petricek">

  <!-- Reference Foundation -->
  <link rel="stylesheet" href="http://tomasp.net/css/foundation.css">
  <script src="js/vendor/custom.modernizr.js"></script>

  <link rel="alternate" type="application/rss+xml" href="http://tomasp.net/rss.xml" title="RSS feed for Tomas Petricek's blog">
  <link rel="icon" type="image/png" href="http://tomasp.net/img/favicon.png" />

  <!-- Reference custom CSS and tooltips -->
  <link type="text/css" rel="stylesheet" href="http://tomasp.net/custom/style.css" />
  <script type="text/javascript" src="http://tomasp.net/custom/tooltips.js"></script>
  <link type="text/css" rel="stylesheet" href="http://tomasp.net/custom/tooltips.css" />
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <meta name="twitter:card" content="summary">
  <meta name="twitter:creator" content="@tomaspetricek">
  <meta name="twitter:title" content="Imperative computation in F# (I.) - Returning results from a function">
  <meta name="twitter:description" content="Even though F# supports some imperative constructs such as for and while loops, it doesn't support some of the advanced constructs like imperative return and break. In this series, we'll look how we can implement these constructs ourselves using F# computation expressions.">
</head>
<body>

   <header id="top-header">
    <div class="row">
      <div class="twelve columns">
        <h1><a href="http://tomasp.net/">Tomas Petricek's blog</a></h1>
        <p>Writing about practical F# coding and programming language research</p>
      </div>
    </div>
  </header>

  <header class="top-bar-header">
    <div class="contain-to-grid sticky">
    <nav class="top-bar">

    <ul class="title-area">
      <li class="name"><h1><a href="#"></a></h1></li>
      <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
    </ul>
    <section class="top-bar-section">
      <ul class="right">
        <li><a href="http://tomasp.net/blog/index.html">Blog</a></li>
        <li><a href="http://functional-programming.net">Books</a></li>
        <li><a href="http://fsharpworks.com/workshops.html">Trainings</a></li>
        <li><a href="http://fsharpworks.com">Consulting</a></li>
        <li><a href="http://tomasp.net/academic">Research</a></li>
      </ul>
    </section>

    </nav></div>
  </header>

  
<div class="row">
	<div class="large-8 columns main-content">
    <content>
      
<h1>Imperative computation in F# (I.) - Returning results from a function</h1>
<p>One of the limitations of F# is that it doesn't very well support some of the 
  advanced imperative language constructs such as <code>break</code>, <code>continue</code>
  or imperative style of returning value from a function, meaning that you can't write
  something like <code>return false</code> in the middle of the function. This has 
  good reasons. F# doesn't in principle have the notion of <em>currently executing statement</em>
  and instead treat every code you write as an expression. Clearly, when there is no 
  <em>current statement</em>, we cannot jump to other statements. If you're looking
  for more information about these basic principles, you can take a look at my book 
  <a href="http://www.functional-programming.net" target="external">Real World Functional 
  Programming</a>, which covers this distinction in details in chapter 2, but we'll look 
  at a brief example that will clarify this idea shortly.</p>

<p>Often, there is really no need to use <code>break</code> or other imperative constructs
  in F#, because you can write the same thing more elegantly using one of the provided higher
  order function such as <code>Seq.exists</code> or <code>Seq.tryfind</code>. However,
  there are still some cases where the imperative programming style makes it easier 
  to express our original intention. Also, implementing your own higher order
  functions (akin to <code>Seq.exists</code>) would sometimes be much easier if we
  could just use imperative return.</p>  

<p>So, what can be done about this? Adding imperative language features to F# seems
  a bit weird (at least to me), because it breaks the nice notion that everything
  is an expression, which makes it easy to reason about what the code does (again, 
  there is an example of this in chapter 2 of my book). On the other hand, having these
  features would be really nice sometimes. In this article series, we'll look how to 
  implement computation expression that allows us to write imperative code in F#.
  Computation expressions (an introduction is in chapter 12) allow us to create blocks
  of F# code that add some non-standard meaning to the usual F# code. In this first 
  article, we'll allow returning from anywhere inside the body using 
  <code>return <em>&lt;expr&gt;</em></code>. In the next articles of the series, we'll
  look at more imperative constructs such as <code>break</code> and <code>continue</code>
  and we'll look even further and explore some features that aren't available in 
  C#, but can be useful sometimes.</p>  

<h2>Programming with expressions</h2>  
<p>When programming in F#, everything is an expression. The easy way to understand
  what this means for a C# programmer is to imagine that we'd have to use conditional
  expressions (<code>&lt;expr&gt;?&lt;expr&gt;:&lt;expr&gt;</code>) instead of the usual
  <code>if</code>-<code>then</code>-<code>else</code> construct. Other constructs such
  as <code>for</code> loop would be also slightly different, but we don't need to go 
  into the details. Now, C# allows you to use <code>return</code> as a <em>statement</em>
  anywhere, but you cannot use it as an <em>expression</em>, which means that the 
  following isn't valid C# code:</p>
<pre>
<span class="k">return</span> 
  (input <span class="o">=</span><span class="o">=</span> 1)
    <span class="o">?</span> (20 <span class="o">+</span> 22) 
    <span class="o">:</span> (4 <span class="o">*</span> (<span class="k">return</span> <span class="k">false</span>));
</pre>  
<p>The purpose of this example was just to demonstrate that disallowing imperative 
  <code>return</code> in F# makes quite a good sense. The next point that I want to make
  before looking how to get imperative programming style in F# is that in many
  situations you don't really need to write the code in the imperative way.
  For example, let's say that you want to return <code>true</code> when some input
  collection of integers contains a number larger than 10 and <code>false</code> otherwise.
  The usual way to write this in C# would be something like this:</p>
<pre>
<span class="k">foreach</span>(<span class="k">var</span> n <span class="k">in</span> input) 
  <span class="k">if</span> (n &gt; 10) <span class="k">return</span> <span class="k">true</span>;
<span class="k">return</span> <span class="k">false</span>;
</pre>
<p>There are various ways to write the same thing in F# - if you wanted to write this
  for the <code>IEnumerable&lt;T&gt;</code> type directly in F#, you couldn't use 
  built-in <code>for</code> loop (because there is no way to return from it). This means
  that you'd have to call <code>GetEnumerator</code> explicitly and write a recursive
  function to do the processing. That sounds like a lot of pain. However, the F#
  library contains many generally useful higher order functions that make problems
  like this trivial. The previous example can be implemented in F# like this: </p>
<pre>
Seq.exists (<span class="k">fun</span> n -&gt; n &gt; 10) input
</pre>
<p>As you can see, this is even easier than the original imperative solution. 
  In fact, when using C# 3.0 and LINQ you would probably use one of the extension
  methods together with C# lambda expressions to write the code in a functional
  way even in C#. This means that before you'll think about using imperative style
  in F#, you should always check whether the same thing cannot be done in a lot
  simpler way using functions like <code>Seq.fold</code>, <code>Seq.exists</code>
  or <code>Seq.tryfind</code>. That said, we can now look how to simulate
  imperative programming in F# when we're really sure that we want it.</p>

<h2>Imperative computations</h2>
<p>When implementing F# computation expression, we need to create a <em>builder</em>
  object that contains a few primitive members that are used to compose the code
  from parts of the computations written by the user. We'll look at the implementation
  of the builder in a second. Once we'll have it - we'll call it <code>ImperativeBuilder</code>,
  we can write the following code to create <code>imperative</code> value that's used when
  writing all the imperative computations.</p>
<pre>
<span class="k">let</span> imperative = <span class="k">new</span> ImperativeBuilder()  
</pre>
<p>This one line of code created the builder, which we can now use to write imperative
  style of code in F#. We'll start by looking at some trivial example to demonstrate
  how the code works under the cover. Then we'll look at the implementation of the
  <code>ImperativeBuilder</code> and finally we'll write some more real world example.
  The following listing shows a single imperative function that contains the <code>return</code>
  statement two times. The behavior should be the same as C# - we want the first value
  to be returned and we don't want the <code>printfn</code> function to be ever called.</p>    
<pre>
<span class="k">let</span> test() = imperative {
  <span class="k">return</span> 0
  printfn <span class="s">"after return!"</span>
  <span class="k">return</span> 1 }
</pre>
<p>When the F# compiler sees this code, it translates it into a couple of calls to 
  primitives provided by the <code>imperative</code> builder. The most important primitives
  for us now are <code>Return</code>, which is used when translating the <code>return</code>
  keyword and <code>Combine</code>. The <code>return</code> keyword denotes the end of a
  sub-expression, so when we use it multiple times, the compiler needs some way to combine
  these sub-expressions into one and that's exactly when it uses the <code>Combine</code>
  primitive.</p>
<pre>
imperative.Run
 (imperative.Combine
   (imperative.Return(0),
    imperative.Delay(<span class="k">fun</span> () <span class="o">-&gt;</span>
      printfn <span class="s">"after return"</span>
      imperative.Return(1))))
</pre>
<p>There are a few other primitives that you can see in this example. We'll talk about them
  shortly when discussing the implementation. However, the important point that the original
  code that contained multiple <code>return</code> constructs (and felt like a sequence of
  statements) has been translated into a standard F# expression.</p>      

<h3>Designing the computation type</h3>  
<p>The key question when implementing computations like this one is what the type 
  of the expression we've seen above is? We'll represent the computation using a type called
  <code>Imperative&lt;'T&gt;</code> and most of the primitives above work with this type.
  In particular, the <code>Return</code> primitive takes a value of some type - in our 
  example above <code>int</code> and returns a value of type <code>Imperative&lt;int&gt;</code>.
  The <code>Combine</code> primitive takes two values of type <code>Imperative&lt;int&gt;</code> 
  as an argument and returns a combined value of the same type.</p>

<p>Now, what should this type look like, so that we can implement the desired imperative
  behavior using the computation builder primitives? First of all, it must be a lazy type, 
  which means that the <code>printfn</code> function shouldn't be called when evaluating
  the arguments for the <code>Combine</code> member. The easiest way to achieve this is
  to write the type as a function that takes a <code>unit</code> as an argument and returns
  something. This means that we don't have to run the second part of the code in the 
  <code>Combine</code> primitive, when the first part already returned some value.</p>  

<p>The second question is - what should be the value returned by this function? We must be
  able to represent computations that don't return any value (for example, when we have 
  <code>if</code>-<code>then</code> loop without the <code>else</code> clause and the condition
  evaluates to <code>false</code>) and we need to represent computations that 
  return something using the <code>return</code> primitive. The usual way to 
  represent a value that may be missing in F# is to use the <code>option&lt;'T&gt;</code>
  type, so we'll end up with a type that looks like this:</p>  

<pre>
<span class="k">type</span> Imperative&lt;'T&gt; = unit -&gt; option&lt;'T&gt;
</pre>

<p>This type can easily represent the two parts of the computation we've seen above.
  The first one (containing only <code>return</code>) will be represented as a function
  that immediately returns a value <code>Some(0)</code> and the second one will be
  represented as a function that prints string using the <code>printfn</code> function
  and then returns a value <code>Some(1)</code>.
  A more complicated computation such as the <code>if</code>-<code>then</code>
  conditional without the <code>else</code> clause would be represented as a function
  that evaluates the condition; if the condition is <code>true</code> it runs the computation in the
  <code>then</code> clause and returns its result and otherwise returns <code>None</code>.</p>

<h3>Implementing the computation</h3>  
<p>Now that we have the type that can represent the computations let's have a look
  at the implementation of the computation builder. We'll start by implementing the
  core primitives that were used in the example above. In the last section 
  of the article, we'll also add support for two looping constructs that can be 
  used inside computation expressions (<code>for</code> and <code>while</code> loops).</p>

<pre>
<span class="k">type</span> ImperativeBuilder() = 
  <span class="c">// Creatae computation that returns the given value  </span>
  <span class="k">member</span> x.Return(v) : Imperative&lt;<span class="o">_</span>&gt; = 
    (<span class="k">fun</span> () -&gt; Some(v))
  <span class="c">// Create computation that doesn't return any value</span>
  <span class="k">member</span> x.Zero() = (<span class="k">fun</span> () -&gt; None)

  <span class="c">// Return a computation that will evaluate the provided function  </span>
  <span class="c">// only when the computation is being evaluated</span>
  <span class="k">member</span> x.Delay(f:unit -&gt; Imperative&lt;<span class="o">_</span>&gt;) = 
    (<span class="k">fun</span> () -&gt; f()())
  
  <span class="c">// Combines two delayed computations (that may return </span>
  <span class="c">// value imperatively using 'return') into one  </span>
  <span class="k">member</span> x.Combine(a, b) = (<span class="k">fun</span> () -&gt;
    <span class="c">// run the first part of the computation</span>
    <span class="k">match</span> a() <span class="k">with</span> 
    <span class="c">// if it returned, we can return the result immediately</span>
    <span class="o">|</span> Some(v) -&gt; Some(v) 
    <span class="c">// otherwise, we need to run the second part</span>
    <span class="o">|</span> <span class="o">_</span> -&gt; b() )
  
  <span class="c">// Execute the imperative computation </span>
  <span class="c">// expression given as an argument</span>
  <span class="k">member</span> x.Run(imp) = 
    <span class="c">// run the computation and return the result or </span>
    <span class="c">// fail when the computation didn't return anything</span>
    <span class="k">match</span> imp() <span class="k">with</span> 
    <span class="o">|</span> Some(v) -&gt; v 
    <span class="o">|</span> None -&gt; failwith <span class="s">"nothing returned!"</span>
</pre>
<p>The first two members give us a way to construct primitive computations. The 
  computation created using <code>Return</code> is used when you write <code>return</code>
  and represents a computation that returns something when executed. The second one
  represents a computation that doesn't do anything and is used in places where
  the F# compiler needs to fill in some blank space (for example when we don't
  provide the <code>else</code> clause). The <code>Delay</code> is also interesting.
  As we've seen when looking at the translation, it is used to wrap the second 
  part of the computation when using <code>Combine</code> to make sure that the
  code which can do some side-effects (such as printing to the console) will be 
  executed only when the second part of the computation is actually needed.</p>

<p>The first three primitives are used for creating individual parts of the computation
  that are later composed together into a single computation that represents the 
  whole imperative block of code. This composition is done using the <code>Combine</code>
  primitive, which will get two computations as an argument. It returns a function
  (delayed computation) that, when executed, tries to run the first computation 
  and returns its result if it returns a value. If the first computation doesn't
  return, it simply runs the second one and returns its result.</p>  

<p>Finally, the computation builder also contains the <code>Run</code> primitive, 
  which is used to wrap the whole computation. Inside this primitive, we run the 
  computation to convert the internal representation (<code>Imperative&lt;'T&gt;</code>)
  into the actual value that we want to return (<code>'T</code>). When the
  computation returns <code>None</code>, we throw an exception because this means
  that the computation completed without ending with any <code>return</code> statement
  (we could also use <code>Unchecked.defaultof&lt;'T&gt;</code> to return 
  zero or <code>null</code> if we wanted to simulate the behavior of C/C++,
  but we don't want to go that far in this article!) .</p>
  
<h2>Real world example</h2>
<p>Now that we've implemented the computation builder, we can take a look at some
  more realistic example where you may want to use imperative coding style. Most of
  the really interesting use cases will need imperative loops, so we'll get back to them
  soon, but even without loops, we can already write quite interesting code. The
  following listing shows a function that validates whether a provided string is a 
  well-formed name. It uses various heuristics such as that the name should be
  at least two words, both reasonably long and both starting with an uppercase letter
  (By the way, sorry if your name doesn't pass the test - it's just a demo!)</p>
<pre>
&gt; <span class="k">let</span> validateName(arg:string) = imperative {
    <span class="c">// Should be non-empty and should contain space</span>
    <span class="k">if</span> (arg = <span class="k">null</span>) <span class="k">then</span> <span class="k">return</span> <span class="k">false</span>
    <span class="k">let</span> idx = arg.IndexOf(<span class="s">" "</span>)
    <span class="k">if</span> (idx = -1) <span class="k">then</span> <span class="k">return</span> <span class="k">false</span>
    
    <span class="c">// Verify the name and the surname</span>
    <span class="k">let</span> name = arg.Substring(0, idx)
    <span class="k">let</span> surname = arg.Substring(idx + 1, arg.Length - idx - 1)
    <span class="k">if</span> (surname.Length &lt; 1 <span class="o">|</span><span class="o">|</span> name.Length &lt; 1) <span class="k">then</span> <span class="k">return</span> <span class="k">false</span>
    <span class="k">if</span> (Char.IsLower(surname.[0]) <span class="o">|</span><span class="o">|</span> Char.IsLower(name.[0])) <span class="k">then</span> <span class="k">return</span> <span class="k">false</span>

    <span class="c">// Looks like we've got a valid name!</span>
    <span class="k">return</span> <span class="k">true</span> }
&lt;em&gt;<span class="k">val</span> validateName : string -&gt; bool&lt;/em&gt;

&gt; validateName(<span class="k">null</span>);;
&lt;em&gt;<span class="k">val</span> it : bool = <span class="k">false</span>&lt;/em&gt;
&gt; validateName(<span class="s">"Tomas"</span>);;
&lt;em&gt;<span class="k">val</span> it : bool = <span class="k">false</span>&lt;/em&gt;
&gt; validateName(<span class="s">"Tomas Petricek"</span>);;
&lt;em&gt;<span class="k">val</span> it : bool = <span class="k">true</span>&lt;/em&gt;
</pre>

<p>The code uses quite common imperative programming pattern. It implements
  various checks that are applied to the name and when the check fails, it 
  immediately returns <code>false</code> as the result, otherwise it continues
  to the next check. In functional languages, this can be implemented either
  using nested <code>if</code>-<code>then</code>-<code>else</code> conditions
  or using pattern matching. If we wanted to avoid nesting in the second case, 
  we'd have to move the entire check into the <code>when</code> clause, which
  would complicate the code. This means, that the code above is quite elegant
  solution for the problem and is in many ways cleaner than code you'd write
  using standard functional constructs.</p>
<p>In this example the difference between imperative and functional version
  would be mostly syntactical. I believe that <em>syntax matters</em>, so this is 
  a good argument for me, but it may not be convincing example for everyone.
  In the next section, we'll add support for using imperative <code>return</code>
  inside loops, which will simplify solving some problems in a more significant way.</p>

<h2>Supporting imperative loops</h2>
<p>If we want to allow the user to write <code>for</code> and <code>while</code> loops
  inside computation expressions, we need to add two additional members to our computation
  builder. In most of the cases, these members can be implemented in terms of other
  primitives (such as <code>Combine</code> and <code>Zero</code>) by using the code
  you can see below. Note that exactly the same code would work for many other computation 
  expressions, because we don't use the <code>Imperative&lt;'T&gt;</code> value directly.
  However, in the next articles of this series, we'll need to change this implementation
  a bit, so it is good that the F# language allows us to implement this ourselves.</p>

<pre>
<span class="k">type</span> ImperativeBuilder <span class="k">with</span>
  <span class="k">member</span> x.For(inp:seq&lt;<span class="o">_</span>&gt;, f) =
    <span class="c">// Process next element from the sequence</span>
    <span class="k">let</span> <span class="k">rec</span> loop(en:IEnumerator&lt;<span class="o">_</span>&gt;) = 
      <span class="c">// If ther are no more elements, return empty computation</span>
      <span class="k">if</span> not(en.MoveNext()) <span class="k">then</span> x.Zero() <span class="k">else</span>
        <span class="c">// Otherwise call body and combine it with a </span>
        <span class="c">// computation that continues looping</span>
        x.Combine(f(en.Current), x.Delay(<span class="k">fun</span> () -&gt; loop(en)))
    <span class="c">// Start enumerating from the first element</span>
    loop(inp.GetEnumerator())
    
  <span class="k">member</span> x.While(gd, body) = 
    <span class="c">// Perform one step of the 'looping'</span>
    <span class="k">let</span> <span class="k">rec</span> loop() =
      <span class="c">// If the condition is false, return empty computation</span>
      <span class="k">if</span> not(gd()) <span class="k">then</span> x.Zero() <span class="k">else</span>
        <span class="c">// Otherwise, call body and then loop again</span>
        x.Combine(body, x.Delay(<span class="k">fun</span> () -&gt; loop()))
    loop()
</pre>
<p>We use type augmentation to add the two members to the existing 
  <code>ImperativeBuilder</code> type. The implementation of both of the new primitives is 
  quite similar. In both of the cases, we create a recursive function that performs
  one step of the looping and returns computation that should be executed after the
  step is performed. This means that the loop is 'unfolded' into a series of
  computation steps that are combined using the <code>Combine</code> primitive
  that we declared above. Note that we're also using the <code>Delay</code> primitive
  to make sure that the next step of the looping is run only when it is actually needed.</p>
<p>As discussed earlier, the <code>Combine</code> member may not need to run the 
  second argument when the computation given as the first argument already returns some
  value (using <code>return</code>). For our looping primitives, this means that
  whenever one step of the looping runs the <code>Return</code> primitive, we'll stop
  looping and immediately return the result. </p>

<h3>Returning from while loop</h3>  
<p>Now, let's have a look at how can we use the looping constructs to solve some 
  real world problems. We'll start with the <code>while</code> loop and we'll use it
  to create a loop that reads names from the console and returns the first one that's valid:</p>  

<pre>
&gt; <span class="k">let</span> readFirstName() = imperative {
    <span class="c">// Loop until the user enters valid name</span>
    <span class="k">while</span> <span class="k">true</span> <span class="k">do</span>
      <span class="k">let</span> name = Console.ReadLine()
      <span class="c">// If the name is valid, we return it, otherwise</span>
      <span class="c">// we continue looping...</span>
      <span class="k">if</span> (validateName(name)) <span class="k">then</span> <span class="k">return</span> name
      printfn <span class="s">"That's not a valid name! Try again..."</span> }
&lt;em&gt;<span class="k">val</span> it : (unit <span class="o">-&gt;</span> string) = &lt;<span class="k">fun</span>:clo@0&gt;&lt;/em&gt;

&gt; readFirstName();;
&lt;em&gt;Tomas
That's not a valid name! Try again...
Tomas Petricek
<span class="k">val</span> it : string = <span class="s">"Tomas Petricek"</span>&lt;/em&gt;
</pre>
<p>The listing starts by implementing the <code>readFirstName</code> function. If we look at 
  its signature printed by the F# interactive, we can see that it returns <code>string</code>,
  which is exactly what we wanted. The function contains an infinite loop written using 
  <code>while true do</code> loop, but because we can imperatively return from loops using
  <code>return</code>, it isn't actually an infinite loop. The function starts by 
  reading a name from the console and then uses the function we created earlier to test
  whether the name is a valid name. If it is valid, then we want to return it as the result
  and if it is not, then we continue looping.</p>
<p>The interesting thing is, how the F# compiler translates the <code>if</code> expression.
  In the <code>true</code> case, it uses calls something like <code>imperative.Return(name)</code>
  to create an imperative computation that returns the name. We didn't provide any code to
  use for the <code>false</code> case, so the compiler uses the "empty computation" we provided
  and generates something like <code>imperative.Zero()</code>. As we've already seen, the 
  <code>Zero</code> member returns a computation that doesn't yet have the return value. 
  This means that when we finish executing the body of the loop and get back to the <code>Combine</code> 
  primitive, it will execute the next iteration of the loop. On the other hand, if we return
  value using <code>Return</code>, the <code>Combine</code> primitive will see that we 
  already have the return value, so it will stop looping.
</p>  

<h3>Returning from for loop</h3>
<p>To finish our discussion, let's look at one more real-world example where the imperative
  <code>return</code> is useful. In the beginning of the article, I wrote that we don't
  need to use imperative constructs in many of the cases, because the F# library contains
  higher order functions that make it possible to express the same thing (often even more
  concisely). However, implementing these higher order functions (such as <code>Seq.exists</code>)
  isn't as easy as it could be. For example, the <code>exists</code> function that takes
  a sequence as an argument has to be implemented by directly using <code>GetEnumerator</code>.</p>
<p>The following example shows that implementing <code>exists</code> function taking
  a sequence and a predicate as arguments using our <code>imperative</code> computation 
  is very easy, because we can simply use <code>for</code> loop to enumerate over the source 
  sequence. When the predicate returns <code>true</code> for the first time, 
  we can immediately terminate the execution and return <code>true</code> as the overall result.</p>
<pre>
&gt; <span class="k">let</span> exists f inp = imperative {
    <span class="k">for</span> v <span class="k">in</span> inp <span class="k">do</span> 
      <span class="k">if</span> f(v) <span class="k">then</span> <span class="k">return</span> <span class="k">true</span>
    <span class="k">return</span> <span class="k">false</span> }
&lt;em&gt;<span class="k">val</span> exists : ('a -&gt; bool) -&gt; seq&lt;'a&gt; <span class="o">-&gt;</span> bool&lt;/em&gt;

&gt; <span class="o">[</span> 1 .. 10 <span class="o">]</span> <span class="o">|</span>&gt; exists (<span class="k">fun</span> v -&gt; v % 3 = 0)
&lt;em&gt;<span class="k">val</span> it : bool = <span class="k">true</span>&lt;/em&gt;
</pre>
<p>As you can see, the implementation of the function couldn't be easier. If the 
  predicate returns true for any of the elements, we imperatively return <code>true</code>
  and if all the elements are enumerated without finding any element like that, 
  we come to the last line of the function, which returns <code>false</code>. It is
  important to note that in the example above, the predicate is executed only
  for elements <code>1</code>, <code>2</code> and <code>3</code>, because when we
  reach <code>3</code>, we can return <code>true</code> without accessing the rest of the list.</p>

<h2>Summary</h2>
<p>In this article, we implemented the first version of the <code>imperative</code> computation
  builder that allows us to use imperative <code>return</code> statement that returns the result
  from any place in the function. We started with a relatively simple version and then we extended
  it to also support two standard F# looping constructs - <code>for</code> and <code>while</code>.
  We also looked at various examples that demonstrate situations where the imperative 
  programming style allows us to write some code in easier way than when implementing the
  same functionality in the purely functional way.</p>
<p>However, there are more imperative constructs that you may sometimes need than just 
  imperative <code>return</code>. In particular, many of the F# users sometimes ask for
  <code>break</code> and <code>continue</code>. Indeed, both of these can be added to our
  computation builder. We'll need to do a minor change to the way we represent the computation,
  but as you'll see in the next article of this series, it is definitely possible to do that
  and it can be done in a very syntactically convenient way.</p>

<h2>Downloads & References<a name="aaaaaaa"></a></h2>
<ul>
  <li><a href="/articles/imperative-fsharp/source.zip">Download the example source code</a></li>
</ul>


<div class="row">
  <div class="small-6 columns"><p class="post-discuss">
		Discuss <a href="http://twitter.com/tomaspetricek">on twitter</a>, <script type="text/javascript" src="http://www.reddit.com/buttonlite.js?i=0"></script>.<br />
		Send corrections via <a href="https://github.com/tpetricek/TomaspNet.Website">GitHub pull requests</a>.
	</p></div>
  <div class="small-6 columns">

<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style addthis_16x16_style">
<a class="addthis_button_twitter"></a>
<a class="addthis_button_reddit"></a>
<a class="addthis_button_google_plusone_share"></a>
<a class="addthis_button_hackernews"></a>
<a class="addthis_button_facebook"></a>
<a class="addthis_button_compact"></a><a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript">var addthis_config = { "data_track_addressbar": false };</script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-521c32162e6001a0"></script>
<!-- AddThis Button END -->

<p class="post-meta">
  <span><strong>Published</strong> Thursday, 19 March 2009, 2:05 AM</span><br />      
  <span><strong>By</strong> <a href="https://plus.google.com/+TomasPetriceks?rel=author">Tomas Petricek</a></span><br />
  <span class="tags"><strong>Tags</strong> Functional Programming in .NET,Academic,F# language</span>
</p>

  </div>
</div>

    </content>

  </div>
  <div class="large-4 columns" id="right-bar">
    <div class="right-item" id="right-calendar">
<script type="text/javascript">
  var monthNames =
    ["January", "February", "March", "April", "May", "June",
      "July", "August", "September", "October", "November", "December"];
  var d = new Date();
  var m = monthNames[d.getMonth()];
  var y = d.getFullYear();
  var ml = m.toLowerCase();
  document.writeln("<h4>Calendar - " + m + " " + y + "</h4>");
  document.writeln("<a href=\"http://tomasp.net/calendar/" + y + "/" + ml + ".html\">" +
    "<img src=\"http://tomasp.net/calendar/" + y + "/" + ml + "-preview.jpg\" style=\"border-style:none;\" />" +
    "</a>");
</script>
<p>The calendar shows a new picture each month. See photos for
  <a href="http://tomasp.net/calendar/2005">2005</a>, <a href="http://tomasp.net/calendar/2006">2006</a>,
  <a href="http://tomasp.net/calendar/2007">2007</a>, <a href="http://tomasp.net/calendar/2008">2008</a>,
  <a href="http://tomasp.net/calendar/2009">2009</a>, <a href="http://tomasp.net/calendar/2010">2010</a>,
  <a href="http://tomasp.net/calendar/2011">2011</a>, <a href="http://tomasp.net/calendar/2012">2012</a>,
  <a href="http://tomasp.net/calendar/2013">2013</a>, <a href="http://tomasp.net/calendar/2014">2014</a>,
  <a href="http://tomasp.net/calendar/2015">2015</a>
  and the first photos of <a href="http://tomasp.net/calendar/2016">2016</a>.
</p>
</div>


    <h3>Welcome!</h3>
    <img src="http://tomasp.net/img/tomas.jpg" alt="Tomas Petricek" style="float:right;margin:10px 0px 10px 10px;" />
    <p>I'm an F# open-source developer, book author and computer scientist. I submitted my PhD thesis recently.
      When offline, I enjoy traveling and taking pictures. You can find me at
      at <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a> or email 
      <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a>.
    </p>

    <h4>Trainings and consulting</h4>
    <a href="http://fsharpworks.com"><img src="http://tomasp.net/img/fsharpworks.png" alt="fsharpWorks" style="float:right;margin:15px 0px 10px 10px; width:150px" /></a>
    <p>I'm an experienced F# developer and trainer. <br /> I offer training and consulting
      services through <a href="http://fsharpworks.com">fsharpWorks</a>.
    </p>
    <ul>
      <li>Check out my <a href="http://fsharpworks.com/workshops/fast-track.html">in-person Fast Track to F#</a> course</li>
      <li>Check out my <a href="http://fsharpworks.com/workshops/finance.html">online F# in Finance</a> course</li>
      <li><a href="mailto:tomas@tomasp.net">Email me</a> for info about private trainings</li>
    </ul>
    
    <script type="text/javascript" src="http://tomasp.net/news/news.js"></script>
    <h4>What's new? &#160; <small><script type="text/javascript">document.write(news.date)</script></small></h4>
    <script>
      document.write(news.info);
    </script>

    <h4>Functional F# and C# books</h4>
    <div style="float:right;">
      <a href="http://www.amazon.com/gp/product/1933988924/ref=as_li_tf_il?ie=UTF8&tag=httptomasnet-20&linkCode=as2&camp=217145&creative=399369&creativeASIN=1933988924">
        <img src="http://tomasp.net/img/deepdives.png" alt="F# Deep Dives" style="float:right;margin:15px 0px 15px 10px;border-style:none;" />
      </a>
    </div>
    <p>
      I wrote or contributed to two books on F# and functional programming:
      <a href="http://functional-programming.net/rwfp">Real World Functional Programming</a> explains functional
      concepts using F# and C# and <a href="http://functional-programming.net/deepdives">F# Deep Dives</a> is a 
      collection of case studies written by industry experts.</p>
    <ul>
      <li><a href="http://functional-programming.net/rwfp"><strong>Real World Functional Programming</strong></a> home page. See
        <a href="http://manning.com/petricek">Manning</a>,
        <a href="https://www.amazon.com/dp/1933988924?tag=httptomasnet-20&camp=213381&creative=390973&linkCode=as4&creativeASIN=1933988924&adid=0F1DP260JGG4KY0CDGP6">Amazon.com</a> or
        <a href="https://www.amazon.co.uk/dp/1933988924?tag=tomasnet-21&camp=1406&creative=6394&linkCode=as1&creativeASIN=1933988924&adid=1CTY87YCCQEJW965GNDF">Amazon.co.uk</a>.
      </li>
      <li><a href="http://functional-programming.net/deepdives"><strong>F# Deep Dives</strong></a> home page. Get it from
        <a href="http://www.manning.com/petricek2">Manning.com</a>,
        <a href="http://www.amazon.com/gp/product/1617291323/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1617291323&linkCode=as2&tag=httptomasnet-20&linkId=U4FPJJSKKCCKGNHD">Amazon.com</a> or
        <a href="http://www.amazon.co.uk/gp/product/1617291323/ref=as_li_tl?ie=UTF8&camp=1634&creative=19450&creativeASIN=1617291323&linkCode=as2&tag=tomasnet-21&linkId=HTUYVHHGWB4Q7X6V">Amazon.co.uk</a>.
      </li>
    </ul>    
    <p>I also wrote a series of tutorials on <a href="http://www.tryfsharp.org/Learn/financial-computing">financial computing for Try F#</a>.
      This interactive environment let's you try F# in the browser.</p>

    <h4>Research and teaching</h4>
    <img src="http://tomasp.net/img/cam.png" alt="University of Cambride" style="float:right;margin:25px 0px 10px 10px;" />
    <p>I submitted my PhD thesis at the <a href="http://www.cl.cam.ac.uk/">University of Cambridge</a>,
      working on making better types for programs that run in rich context (like F# type providers, distributed 
      prog&shy;ramming or data-flow). See <a href="http://tomasp.net/academic/">my academic page</a> for
      more.</p>

    <h4>Blog tags</h4>
    <p>

      <a href="http://tomasp.net/blog/tag/fsharp/">f#</a>&nbsp;(109),       <a href="http://tomasp.net/blog/tag/research/">research</a>&nbsp;(34),       <a href="http://tomasp.net/blog/tag/functional-programming/">functional programming</a>&nbsp;(18),       <a href="http://tomasp.net/blog/tag/csharp/">c#</a>&nbsp;(36),       <a href="http://tomasp.net/blog/tag/data-science/">data science</a>&nbsp;(6),       <a href="http://tomasp.net/blog/tag/web/">web</a>&nbsp;(10),       <a href="http://tomasp.net/blog/tag/talks/">talks</a>&nbsp;(7),       <a href="http://tomasp.net/blog/tag/philosophy/">philosophy</a>&nbsp;(4),       <a href="http://tomasp.net/blog/tag/fslab/">fslab</a>&nbsp;(4),       <a href="http://tomasp.net/blog/tag/programming-languages/">programming languages</a>&nbsp;(3),       <a href="http://tomasp.net/blog/tag/type-providers/">type providers</a>&nbsp;(3),       <a href="http://tomasp.net/blog/tag/data-journalism/">data journalism</a>&nbsp;(2),       <a href="http://tomasp.net/blog/tag/linq/">linq</a>&nbsp;(3),       <a href="http://tomasp.net/blog/tag/coeffects/">coeffects</a>&nbsp;(2),       <a href="http://tomasp.net/blog/tag/deedle/">deedle</a>&nbsp;(2),       <a href="http://tomasp.net/blog/tag/visualization/">visualization</a>&nbsp;(1),       <a href="http://tomasp.net/blog/tag/machine-learning/">machine learning</a>&nbsp;(1)    </p>

  </div>
</div>


  <div class="row" id="footer">
  <footer>
    <div class="large-3 columns">
      <h4>Contact & about</h4>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>.
        For more info, see the <a href="https://github.com/tpetricek/TomaspNet.Website">website source on GitHub</a>.
      </p>
      <p>Please submit issues & corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li>Email me: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
        <li>Connect via Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li>More: <a href="http://uk.linkedin.com/in/tomaspetricek">LinkedIn</a> | <a href="http://lanyrd.com/profile/tomasp/">Lanyrd</a> | <a href="https://github.com/tpetricek">GitHub</a></li>
      </ul>
    </div>
    <div class="large-7 columns">
    <h4>Blog archives <a href="http://tomasp.net/rss.xml"><img src="http://tomasp.net/img/rss.gif" /></a></h4>
      <a href="http://tomasp.net/blog/archive/april-2016/index.html">
        April 2016 (1)</a>,      <a href="http://tomasp.net/blog/archive/december-2015/index.html">
        December 2015 (2)</a>,      <a href="http://tomasp.net/blog/archive/november-2015/index.html">
        November 2015 (1)</a>,      <a href="http://tomasp.net/blog/archive/september-2015/index.html">
        September 2015 (3)</a>,      <a href="http://tomasp.net/blog/archive/july-2015/index.html">
        July 2015 (1)</a>,      <a href="http://tomasp.net/blog/archive/june-2015/index.html">
        June 2015 (1)</a>,      <a href="http://tomasp.net/blog/archive/may-2015/index.html">
        May 2015 (2)</a>,      <a href="http://tomasp.net/blog/archive/april-2015/index.html">
        April 2015 (3)</a>,      <a href="http://tomasp.net/blog/archive/march-2015/index.html">
        March 2015 (2)</a>,      <a href="http://tomasp.net/blog/archive/february-2015/index.html">
        February 2015 (1)</a>,      <a href="http://tomasp.net/blog/archive/january-2015/index.html">
        January 2015 (2)</a>,      <a href="http://tomasp.net/blog/archive/december-2014/index.html">
        December 2014 (1)</a>,      <a href="http://tomasp.net/blog/archive/may-2014/index.html">
        May 2014 (3)</a>,      <a href="http://tomasp.net/blog/archive/april-2014/index.html">
        April 2014 (2)</a>,      <a href="http://tomasp.net/blog/archive/march-2014/index.html">
        March 2014 (1)</a>,      <a href="http://tomasp.net/blog/archive/january-2014/index.html">
        January 2014 (2)</a>,      <a href="http://tomasp.net/blog/archive/december-2013/index.html">
        December 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/november-2013/index.html">
        November 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/october-2013/index.html">
        October 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/september-2013/index.html">
        September 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/august-2013/index.html">
        August 2013 (2)</a>,      <a href="http://tomasp.net/blog/archive/may-2013/index.html">
        May 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/april-2013/index.html">
        April 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/march-2013/index.html">
        March 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/february-2013/index.html">
        February 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/january-2013/index.html">
        January 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/december-2012/index.html">
        December 2012 (2)</a>,      <a href="http://tomasp.net/blog/archive/october-2012/index.html">
        October 2012 (1)</a>,      <a href="http://tomasp.net/blog/archive/august-2012/index.html">
        August 2012 (3)</a>,      <a href="http://tomasp.net/blog/archive/june-2012/index.html">
        June 2012 (2)</a>,      <a href="http://tomasp.net/blog/archive/april-2012/index.html">
        April 2012 (1)</a>,      <a href="http://tomasp.net/blog/archive/march-2012/index.html">
        March 2012 (4)</a>,      <a href="http://tomasp.net/blog/archive/february-2012/index.html">
        February 2012 (5)</a>,      <a href="http://tomasp.net/blog/archive/january-2012/index.html">
        January 2012 (2)</a>,      <a href="http://tomasp.net/blog/archive/november-2011/index.html">
        November 2011 (5)</a>,      <a href="http://tomasp.net/blog/archive/august-2011/index.html">
        August 2011 (3)</a>,      <a href="http://tomasp.net/blog/archive/july-2011/index.html">
        July 2011 (2)</a>,      <a href="http://tomasp.net/blog/archive/june-2011/index.html">
        June 2011 (2)</a>,      <a href="http://tomasp.net/blog/archive/may-2011/index.html">
        May 2011 (2)</a>,      <a href="http://tomasp.net/blog/archive/march-2011/index.html">
        March 2011 (4)</a>,      <a href="http://tomasp.net/blog/archive/december-2010/index.html">
        December 2010 (1)</a>,      <a href="http://tomasp.net/blog/archive/november-2010/index.html">
        November 2010 (6)</a>,      <a href="http://tomasp.net/blog/archive/october-2010/index.html">
        October 2010 (6)</a>,      <a href="http://tomasp.net/blog/archive/september-2010/index.html">
        September 2010 (4)</a>,      <a href="http://tomasp.net/blog/archive/july-2010/index.html">
        July 2010 (3)</a>,      <a href="http://tomasp.net/blog/archive/june-2010/index.html">
        June 2010 (2)</a>,      <a href="http://tomasp.net/blog/archive/may-2010/index.html">
        May 2010 (1)</a>,      <a href="http://tomasp.net/blog/archive/february-2010/index.html">
        February 2010 (2)</a>,      <a href="http://tomasp.net/blog/archive/january-2010/index.html">
        January 2010 (3)</a>,      <a href="http://tomasp.net/blog/archive/december-2009/index.html">
        December 2009 (3)</a>,      <a href="http://tomasp.net/blog/archive/july-2009/index.html">
        July 2009 (1)</a>,      <a href="http://tomasp.net/blog/archive/june-2009/index.html">
        June 2009 (3)</a>,      <a href="http://tomasp.net/blog/archive/may-2009/index.html">
        May 2009 (2)</a>,      <a href="http://tomasp.net/blog/archive/april-2009/index.html">
        April 2009 (1)</a>,      <a href="http://tomasp.net/blog/archive/march-2009/index.html">
        March 2009 (2)</a>,      <a href="http://tomasp.net/blog/archive/february-2009/index.html">
        February 2009 (1)</a>,      <a href="http://tomasp.net/blog/archive/december-2008/index.html">
        December 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/november-2008/index.html">
        November 2008 (5)</a>,      <a href="http://tomasp.net/blog/archive/october-2008/index.html">
        October 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/september-2008/index.html">
        September 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/june-2008/index.html">
        June 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/march-2008/index.html">
        March 2008 (3)</a>,      <a href="http://tomasp.net/blog/archive/february-2008/index.html">
        February 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/december-2007/index.html">
        December 2007 (2)</a>,      <a href="http://tomasp.net/blog/archive/november-2007/index.html">
        November 2007 (6)</a>,      <a href="http://tomasp.net/blog/archive/october-2007/index.html">
        October 2007 (1)</a>,      <a href="http://tomasp.net/blog/archive/september-2007/index.html">
        September 2007 (1)</a>,      <a href="http://tomasp.net/blog/archive/august-2007/index.html">
        August 2007 (1)</a>,      <a href="http://tomasp.net/blog/archive/july-2007/index.html">
        July 2007 (2)</a>,      <a href="http://tomasp.net/blog/archive/april-2007/index.html">
        April 2007 (2)</a>,      <a href="http://tomasp.net/blog/archive/march-2007/index.html">
        March 2007 (3)</a>,      <a href="http://tomasp.net/blog/archive/february-2007/index.html">
        February 2007 (3)</a>,      <a href="http://tomasp.net/blog/archive/january-2007/index.html">
        January 2007 (2)</a>,      <a href="http://tomasp.net/blog/archive/november-2006/index.html">
        November 2006 (1)</a>,      <a href="http://tomasp.net/blog/archive/october-2006/index.html">
        October 2006 (3)</a>,      <a href="http://tomasp.net/blog/archive/august-2006/index.html">
        August 2006 (2)</a>,      <a href="http://tomasp.net/blog/archive/july-2006/index.html">
        July 2006 (1)</a>,      <a href="http://tomasp.net/blog/archive/june-2006/index.html">
        June 2006 (3)</a>,      <a href="http://tomasp.net/blog/archive/may-2006/index.html">
        May 2006 (2)</a>,      <a href="http://tomasp.net/blog/archive/april-2006/index.html">
        April 2006 (2)</a>,      <a href="http://tomasp.net/blog/archive/december-2005/index.html">
        December 2005 (1)</a>,      <a href="http://tomasp.net/blog/archive/july-2005/index.html">
        July 2005 (4)</a>,      <a href="http://tomasp.net/blog/archive/june-2005/index.html">
        June 2005 (5)</a>,      <a href="http://tomasp.net/blog/archive/may-2005/index.html">
        May 2005 (1)</a>,      <a href="http://tomasp.net/blog/archive/april-2005/index.html">
        April 2005 (3)</a>,      <a href="http://tomasp.net/blog/archive/march-2005/index.html">
        March 2005 (3)</a>,      <a href="http://tomasp.net/blog/archive/january-2005/index.html">
        January 2005 (1)</a>,      <a href="http://tomasp.net/blog/archive/december-2004/index.html">
        December 2004 (3)</a>,      <a href="http://tomasp.net/blog/archive/november-2004/index.html">
        November 2004 (2)</a>,    </div>
    <div class="large-2 columns">
      <h4>License</h4>
      <p>Unless explicitly mentioned, all articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>.
        All source code samples are licensed under Apache 2.0.
      </p>
      <img src="http://tomasp.net/img/cc-sa.png" alt="CC License logo" />
    </div>
  </footer>
  </div>

  <script>
  document.write('<script src=' +
  ('__proto__' in {} ? 'http://tomasp.net/js/vendor/zepto' : 'http://tomasp.net/js/vendor/jquery') +
  '.js><\/script>')
  </script>

  <script src="http://tomasp.net/js/foundation.min.js"></script>
  <script>
    $(document).foundation();
  </script>
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);

    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
  <script src="http://cdn.lanyrd.net/badges/person-v1.min.js"></script>
</body>
</html>
